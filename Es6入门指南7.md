###其他的解构赋值

#### 字符串的解构赋值

字符串也可以结构赋值，此时字符串被转换成了一个类数组对象。
```javascript
 const [a,b,c,d,e] = 'hello'
 a//'h'
 b//'e'
 c//'l'
 d//'l'
 e//'o'
```
类数组对象都有length属性，因此还可以对这个属性解构赋值。
```javascript
 let {length: len} = 'hello'
 //len=5
```

#### 数值与布尔值的解构赋值
 1. 解构赋值时，如果等号右边是数值或者布尔值，则会先转为对象。
 ```javascript
  let {toString: s} = 123
  s === Number.prototype.toString // true

  let {toString: s} = true
  s === Boolean.prototype.toString //true
 ```
 2. 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对像，由于undefined和null无法转为对象，所以对他们进行解构赋值赋值都会报错。

#### 函数参数的解构赋值

1. 函数参数的解构赋值
```javascript
 function add([x,y]){
  return x + y
 }
 add(1,2)//3
``` 
2. add的参数实际上不是一个数组，而是通过解构得到的变量x，y
3. 函数参数的解构也可以使用默认值。
 ```javascript
  function move({x=0,y=0} = {}){ return [x,y]}
  move({x:3,y:8})//[3,8]
  move({y:8})//[0,8]
  move()//[0,0]
  move({})//[0,0]
 ```
4. 默认值的变型
 ```javascript
  function move({x,y}={x:0,y:0}){
   return [x,y]
  }
  move({x:3,y:8})//[3,8]
  move({x:3})//[3,undefined]
  move({})//[undefined,undefined]
  move()//[0,0]
 ```
 上面的代码是为函数move的参数指定默认值，而不是为了变量x，y指定默认值，所以会得与前一种写法不同的结果。

5. undefined会出发函数参数的默认值
```javascript
 [1,undefined,3].map((x = 'yes')=>x)
 //[1,'yes',3]
```

### 关于圆括号！
上节我们说了，圆括号是为了解决对象解构赋值的时候，花括号存在于行首这样的情况出现。

#### 那么什么时候我们是不能使用圆括号呢？？
 1. 变量声明语句中，模式不能使用圆括号
 ```javascript
  let [(a)] = [1]
  let {x:(c)} = {} 
  let {o:(p:p)} = {o:{p:2}}//全部报错
 ```
 2. 函数参数重，模式不能带有圆括号
 ```javascript
  function f([(z)]){ return z}//报错
 ```
 3. 不能将整个模式或嵌套模式中的一层放入圆括号里
 ```javascript
  ({p:a}) = {p:42}
  ([a]) = [5]//全部报错
 ```
#### 可以使用圆括号的情况
可以使用圆括号的情况只有一种：赋值语句的非模式部分可以使用圆括号
```javascript
 [(b)] = [3]
 ({p:{b}}) = {} //正确
```
解释：1.他们都是赋值语句，而不是声明语句
     2.他们的圆括号都不属于模式的一部分

### 解构赋值的用途

1. 变换变量的值
```
[x,y] = [y,x]
```
2. 从函数返回多个值
